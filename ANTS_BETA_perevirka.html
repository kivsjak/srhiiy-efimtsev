<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ants vs Plants - Tug of War</title>
    <style>
        :root {
            --primary: #fbbf24; /* Brighter Amber */
            --primary-dark: #b45309;
            --bg-dark: #1c1917;
            --panel-bg: #292524;
            --text-light: #e7e5e4;
            --accent-green: #4ade80; /* Neon Green */
            --accent-red: #f87171;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: #0c0a09;
            background: linear-gradient(180deg, #1a100c 0%, #000000 100%);
            color: var(--text-light);
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .game-wrapper {
            position: relative;
            width: 100%;
            max-width: 1200px;
            height: 100vh;
            max-height: 900px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 50px rgba(0,0,0,0.9);
            border-radius: 12px;
            overflow: hidden;
            background: #2a2018;
            border: 4px solid #78350f;
        }

        /* --- INFO BAR --- */
        .info-bar {
            display: flex;
            justify-content: space-between;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.9);
            border-bottom: 3px solid #78350f;
            z-index: 10;
        }

        .info-item {
            text-align: center;
            min-width: 80px;
        }

        .info-label {
            color: #9ca3af;
            font-size: 0.75rem;
            text-transform: uppercase;
            margin-bottom: 2px;
            font-weight: 700;
            letter-spacing: 1px;
        }

        .info-value {
            color: var(--primary);
            font-size: 1.2rem;
            font-weight: 900;
            text-shadow: 0 0 10px rgba(251, 191, 36, 0.4);
        }

        /* --- MULTIPLIER ROW --- */
        .multiplier-row {
            display: flex;
            gap: 6px;
            justify-content: center;
            padding: 12px;
            background: #271c19;
            border-bottom: 3px solid #78350f;
            z-index: 9;
            overflow-x: auto;
        }

        .mult-item {
            padding: 6px 12px;
            background: #44403c;
            border: 2px solid #57534e;
            border-radius: 6px;
            color: #a8a29e;
            font-weight: 800;
            font-size: 0.95rem;
            min-width: 55px;
            text-align: center;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .mult-item.active {
            background: #0284c7;
            border-color: #38bdf8;
            color: #fff;
            transform: scale(1.15) translateY(-2px);
            box-shadow: 0 4px 15px rgba(14, 165, 233, 0.5);
            z-index: 2;
        }

        .mult-item.winning {
            background: #15803d;
            border-color: #4ade80;
            color: #fff;
        }

        /* --- CANVAS AREA --- */
        .canvas-container {
            flex: 1;
            position: relative;
            background-color: #2b1d1a; /* Darker, cooler brown base */
            /* Complex texture pattern for rich ground */
            background-image: 
                radial-gradient(circle at 50% 50%, rgba(0,0,0,0) 0%, rgba(0,0,0,0.6) 100%),
                url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.7' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.15'/%3E%3C/svg%3E");
            
            cursor: none;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            position: relative;
            z-index: 1;
        }

        .crosshair {
            position: absolute;
            width: 44px;
            height: 44px;
            pointer-events: none;
            z-index: 100;
            transform: translate(-50%, -50%);
            display: none;
            border: 3px solid rgba(173, 255, 47, 0.8); 
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(173, 255, 47, 0.6);
            transition: transform 0.1s;
        }

        .crosshair::before, .crosshair::after {
            content: '';
            position: absolute;
            background: #ccff00;
            box-shadow: 0 0 8px #ccff00;
        }
        .crosshair::before { top: 19px; left: 6px; width: 32px; height: 3px; }
        .crosshair::after { left: 19px; top: 6px; height: 32px; width: 3px; }

        .current-mult-float {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.85);
            border: 2px solid var(--primary);
            padding: 8px 20px;
            border-radius: 30px;
            font-size: 1.8rem;
            color: var(--primary);
            font-weight: 900;
            display: none;
            z-index: 50;
            text-shadow: 0 0 10px rgba(251, 191, 36, 0.5);
        }

        /* --- CONTROLS BAR --- */
        .controls {
            background: linear-gradient(135deg, #1c1917 0%, #0c0a09 100%);
            padding: 20px;
            border-top: 4px solid #78350f;
            display: grid;
            grid-template-columns: 1fr 1.5fr 1fr;
            gap: 25px;
            align-items: center;
            position: relative;
            z-index: 20;
            box-shadow: 0 -10px 30px rgba(0,0,0,0.5);
        }

        @media (max-width: 768px) {
            .controls { grid-template-columns: 1fr; padding: 15px; }
        }

        /* Bet Section */
        .control-col { display: flex; flex-direction: column; gap: 10px; }
        .label { color: var(--primary); font-size: 0.85rem; font-weight: 800; text-transform: uppercase; letter-spacing: 1px; }

        .bet-input-group {
            display: flex;
            align-items: center;
            gap: 5px;
            background: #000;
            padding: 8px;
            border-radius: 8px;
            border: 2px solid #4b5563;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.5);
        }

        .bet-input-group input {
            background: transparent;
            border: none;
            color: #fff;
            font-size: 1.4rem;
            font-weight: 900;
            width: 100%;
            text-align: center;
            outline: none;
        }

        .quick-buttons { display: flex; gap: 6px; justify-content: center; }
        
        .quick-btn {
            padding: 8px 12px;
            background: linear-gradient(to bottom, #57534e, #292524);
            border: 1px solid #1c1917;
            border-radius: 6px;
            color: #e5e7eb;
            font-weight: 800;
            font-size: 0.75rem;
            cursor: pointer;
            flex: 1;
            box-shadow: 0 2px 0 #1c1917;
            transition: all 0.1s;
        }
        .quick-btn:hover:not(:disabled) { background: #78716c; transform: translateY(-1px); }
        .quick-btn:active:not(:disabled) { transform: translateY(2px); box-shadow: none; }
        .quick-btn:disabled { opacity: 0.4; cursor: not-allowed; }

        /* Difficulty Section */
        .difficulty-buttons {
            display: flex;
            gap: 6px;
            background: #1a1512;
            padding: 6px;
            border-radius: 10px;
            border: 1px solid #444;
        }

        .difficulty-btn {
            flex: 1;
            padding: 12px 5px;
            background: transparent;
            border: 1px solid transparent;
            color: #9ca3af;
            font-weight: 800;
            font-size: 0.8rem;
            cursor: pointer;
            border-radius: 6px;
            text-transform: uppercase;
            transition: 0.2s;
        }

        .difficulty-btn.active {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            border: 1px solid #34d399;
            box-shadow: 0 4px 10px rgba(16, 185, 129, 0.4);
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        .difficulty-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Play Button */
        .play-button {
            width: 100%;
            height: 70px;
            background: linear-gradient(135deg, #0ea5e9, #0369a1);
            border: 2px solid #38bdf8;
            border-bottom-width: 6px;
            border-radius: 12px;
            color: white;
            font-size: 1.8rem;
            font-weight: 900;
            text-transform: uppercase;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(14, 165, 233, 0.4);
            transition: all 0.1s;
            text-shadow: 0 2px 0 rgba(0,0,0,0.3);
            letter-spacing: 1px;
        }
        
        .play-button:active:not(:disabled) {
            transform: translateY(4px);
            border-bottom-width: 2px;
            box-shadow: none;
        }
        
        .play-button.cashout {
            background: linear-gradient(135deg, #22c55e, #15803d);
            border-color: #86efac;
            box-shadow: 0 5px 15px rgba(34, 197, 94, 0.4);
        }

        .play-button:disabled {
            background: #4b5563;
            border-color: #6b7280;
            box-shadow: none;
            cursor: not-allowed;
            transform: none;
            border-bottom-width: 2px;
        }

        /* Status Overlay */
        .status-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            display: none;
        }
        
        .status-content {
            background: #1c1917;
            border: 4px solid var(--primary);
            padding: 50px;
            border-radius: 20px;
            text-align: center;
            animation: zoomIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }

        @keyframes zoomIn { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        .status-title { font-size: 3rem; margin-bottom: 15px; text-transform: uppercase; font-weight: 900; letter-spacing: 2px; }
        .status-text { font-size: 1.4rem; color: #d1d5db; margin-bottom: 30px; }
        .status-btn {
            padding: 15px 40px;
            background: var(--primary);
            color: #000;
            border: 2px solid #fcd34d;
            font-weight: 900;
            font-size: 1.1rem;
            border-radius: 8px;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 4px 0 #b45309;
            transition: all 0.1s;
        }
        .status-btn:active { transform: translateY(4px); box-shadow: none; }
        .status-btn:hover { background: #fbbf24; filter: brightness(1.1); }

        .text-win { color: #4ade80; text-shadow: 0 0 20px rgba(74, 222, 128, 0.6); }
        .text-loss { color: #f87171; text-shadow: 0 0 20px rgba(248, 113, 113, 0.6); }

    </style>
</head>
<body>

<div class="game-wrapper">
    <!-- Info Bar -->
    <div class="info-bar">
        <div class="info-item">
            <div class="info-label">Balance</div>
            <div class="info-value" id="balance">$1000.00</div>
        </div>
        <div class="info-item">
            <div class="info-label">Danger Level</div>
            <div class="info-value" id="danger-level">50%</div>
        </div>
        <div class="info-item">
            <div class="info-label">Level</div>
            <div class="info-value" id="level">1</div>
        </div>
        <div class="info-item">
            <div class="info-label">Hits</div>
            <div class="info-value" id="hits">0</div>
        </div>
    </div>

    <!-- Multiplier Row -->
    <div class="multiplier-row" id="multiplier-row">
        <!-- JS Generated -->
    </div>

    <!-- Canvas -->
    <div class="canvas-container" id="canvas-container">
        <canvas id="gameCanvas"></canvas>
        <div class="crosshair" id="crosshair"></div>
        <div class="current-mult-float" id="float-mult">x1.00</div>
    </div>

    <!-- Controls -->
    <div class="controls">
        <!-- Bet Amount -->
        <div class="control-col">
            <div class="label">Bet Amount</div>
            <div class="bet-input-group">
                <span style="color:var(--primary); font-weight:bold; margin-left:5px;">$</span>
                <input type="number" id="bet-input" value="10.00" step="0.01">
            </div>
            <div class="quick-buttons">
                <button class="quick-btn" id="btn-half">1/2</button>
                <button class="quick-btn" id="btn-double">2X</button>
                <button class="quick-btn" id="btn-minus">-</button>
                <button class="quick-btn" id="btn-plus">+</button>
            </div>
        </div>

        <!-- Difficulty -->
        <div class="control-col">
            <div class="label" style="text-align:center;">Difficulty</div>
            <div class="difficulty-buttons" id="diff-container">
                <button class="difficulty-btn" data-diff="easy">Easy</button>
                <button class="difficulty-btn active" data-diff="medium">Medium</button>
                <button class="difficulty-btn" data-diff="hard">Hard</button>
                <button class="difficulty-btn" data-diff="expert">Expert</button>
                <button class="difficulty-btn" data-diff="crazy">Crazy</button>
            </div>
        </div>

        <!-- Play Button -->
        <div class="control-col">
            <button class="play-button" id="play-btn">PLAY</button>
        </div>
    </div>

    <!-- Overlay -->
    <div class="status-overlay" id="overlay">
        <div class="status-content">
            <h2 class="status-title" id="overlay-title">VICTORY</h2>
            <p class="status-text" id="overlay-text">Vine Repelled!</p>
            <div style="display:flex; gap:15px; justify-content:center;">
                <button class="status-btn" id="overlay-btn-1">Continue</button>
                <button class="status-btn" id="overlay-btn-2" style="background:#4b5563; border-color:#6b7280; color:white;">Stay</button>
            </div>
        </div>
    </div>
</div>

<script>
/**
 * --- CONFIGURATION & CONSTANTS ---
 */
const CONFIG = {
    // Game mechanics
    StartProgress: 0.5, // 50%
    CrawlSpeed: 0.0003, // Progress per frame
    PushbackForce: 0.08, // Progress reduction on hit
    CashoutPenalty: 0.05, // Progress penalty on cashout
    
    // Visuals
    HeadSpacing: 40, // Distance between heads
    GroupGap: 120, // Distance between groups
    ZigZagOffset: 25, // Offset from stem center
    
    BET_SEQUENCE: [
        0.01, 0.02, 0.05, 0.10, 0.20, 0.50,
        1.00, 2.00, 5.00, 10.00, 20.00, 50.00,
        100.00, 200.00, 500.00, 1000.00, 2000.00, 5000.00
    ],

    DIFFICULTIES: {
        easy: { label: 'Easy', probability: 0.75, multipliers: [1.1, 1.2, 1.4, 1.6, 2.0, 2.5, 3.2, 4.0, 5.0, 7.0, 10.0] },
        medium: { label: 'Medium', probability: 0.667, multipliers: [1.2, 1.4, 1.7, 2.1, 2.6, 3.4, 4.5, 6.0, 8.0, 12.0, 18.0] },
        hard: { label: 'Hard', probability: 0.50, multipliers: [1.3, 1.6, 2.0, 2.6, 3.5, 4.8, 6.5, 9.0, 13.0, 20.0, 30.0] },
        expert: { label: 'Expert', probability: 0.333, multipliers: [1.5, 2.0, 2.8, 4.0, 6.0, 9.0, 14.0, 22.0, 35.0, 55.0, 90.0] },
        crazy: { label: 'Crazy', probability: 0.25, multipliers: [1.8, 2.5, 4.0, 6.5, 11.0, 18.0, 30.0, 50.0, 85.0, 150.0, 250.0] }
    }
};

/**
 * --- GAME STATE ---
 */
const gameState = {
    balance: 1000.00,
    vineProgress: 0.5, // 0.0 to 1.0
    currentLevel: 1,
    betAmount: 10.00,
    difficulty: 'medium',

    roundActive: false,
    consecutiveHits: 0,
    
    uiLocked: false,
    mouseX: 0,
    mouseY: 0,
    
    path: [],
    projectiles: [],
    particles: [],
    floatingTexts: [], // For comic "HIT" effects
    
    // The Vine Logic
    heads: [] // Array of head objects relative to stem front
};

/**
 * --- CANVAS SETUP ---
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const container = document.getElementById('canvas-container');

function resize() {
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
    generatePath();
}
window.addEventListener('resize', resize);

/**
 * --- PATH & VINE GENERATION ---
 */
function generatePath() {
    const w = canvas.width;
    const h = canvas.height;
    gameState.path = [];

    // Dense path points for smooth movement
    const points = [
        {x: 0, y: 50},
        {x: w * 0.9, y: 50},
        {x: w * 0.9, y: h * 0.4},
        {x: w * 0.1, y: h * 0.45},
        {x: w * 0.1, y: h * 0.85},
        {x: w * 0.8, y: h * 0.85},
        {x: w - 50, y: h - 50}
    ];
    
    // Subdivide
    for (let i = 0; i < points.length - 1; i++) {
        const p0 = points[i];
        const p1 = points[i+1];
        const dist = Math.hypot(p1.x - p0.x, p1.y - p0.y);
        const steps = Math.floor(dist); 
        
        for (let j = 0; j < steps; j++) {
            const t = j / steps;
            gameState.path.push({
                x: p0.x + (p1.x - p0.x) * t,
                y: p0.y + (p1.y - p0.y) * t
            });
        }
    }
}

function generateVineHeads() {
    gameState.heads = [];
    
    // We generate heads trailing behind the "Front" (offset 0)
    const colors = ['#ef4444', '#3b82f6', '#eab308', '#a855f7'];
    let currentOffset = 0; // Distance from front (positive number going back)
    
    for (let g = 0; g < 10; g++) { // 10 groups
        const color = colors[g % colors.length];
        
        // 4 Heads per group
        for (let h = 0; h < 4; h++) {
            // Add gap in middle of group
            if (h === 2) currentOffset += CONFIG.HeadSpacing * 0.8;
            
            gameState.heads.push({
                offset: currentOffset,
                side: (h % 2 === 0) ? -1 : 1, // ZigZag: Top/Bottom or Left/Right
                color: color,
                groupIndex: g,
                isDead: false,
                id: g * 4 + h
            });
            
            currentOffset += CONFIG.HeadSpacing;
        }
        
        // Large gap between groups
        currentOffset += CONFIG.GroupGap;
    }
}

/**
 * --- GAME LOGIC ---
 */

function initGame() {
    loadState();
    resize();
    generateVineHeads();
    updateUI();
    generateMultipliers();
    setupInputs();
    requestAnimationFrame(gameLoop);
}

function loadState() {
    const saved = localStorage.getItem('antsVsPlants_state');
    if (saved) {
        const data = JSON.parse(saved);
        gameState.balance = data.balance ?? 1000;
        gameState.currentLevel = data.currentLevel ?? 1;
        gameState.betAmount = data.betAmount ?? 10;
        gameState.difficulty = data.difficulty ?? 'medium';
    }
    document.getElementById('bet-input').value = gameState.betAmount.toFixed(2);
    document.querySelectorAll('.difficulty-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.diff === gameState.difficulty);
    });
}

function saveState() {
    localStorage.setItem('antsVsPlants_state', JSON.stringify({
        balance: gameState.balance,
        currentLevel: gameState.currentLevel,
        betAmount: gameState.betAmount,
        difficulty: gameState.difficulty
    }));
}

function startRound() {
    if (gameState.betAmount > gameState.balance) {
        alert("Insufficient balance!");
        return;
    }
    
    gameState.balance -= gameState.betAmount;
    gameState.roundActive = true;
    gameState.consecutiveHits = 0;
    gameState.vineProgress = CONFIG.StartProgress;
    gameState.uiLocked = true;
    
    // Revive all heads
    gameState.heads.forEach(h => h.isDead = false);
    
    updateUI();
    lockUI(true);
    
    const btn = document.getElementById('play-btn');
    btn.textContent = "CASHOUT";
    btn.classList.add('cashout');
    
    document.getElementById('crosshair').style.display = 'block';
    document.getElementById('float-mult').style.display = 'block';
    document.getElementById('float-mult').textContent = "x" + getCurrentMultiplier().toFixed(2);
    
    saveState();
}

function endRound() {
    gameState.roundActive = false;
    gameState.uiLocked = false;
    
    updateUI();
    lockUI(false);
    
    const btn = document.getElementById('play-btn');
    btn.textContent = "PLAY";
    btn.classList.remove('cashout');
    
    document.getElementById('crosshair').style.display = 'none';
    document.getElementById('float-mult').style.display = 'none';
    
    saveState();
}

function updateGameLogic() {
    if (!gameState.roundActive) return;

    // Constant Motion
    gameState.vineProgress += CONFIG.CrawlSpeed;

    // Defeat Check
    if (gameState.vineProgress >= 1.0) {
        triggerDefeat();
    }
    
    // Victory Check (0% or less)
    if (gameState.vineProgress <= 0.0) {
        triggerVictory();
    }
    
    // Update danger label
    document.getElementById('danger-level').textContent = Math.floor(gameState.vineProgress * 100) + "%";
}

function onShoot() {
    if (!gameState.roundActive) return;

    // Hit Logic
    const diff = CONFIG.DIFFICULTIES[gameState.difficulty];
    const isSuccess = Math.random() < diff.probability;
    
    spawnProjectile(isSuccess);
}

function resolveShot(isSuccess) {
    if (isSuccess) {
        // HIT (Success)
        // Push Back
        gameState.vineProgress = Math.max(0, gameState.vineProgress - CONFIG.PushbackForce);
        gameState.consecutiveHits++;
        
        // Spawn Floating Text
        const lastProj = gameState.projectiles[gameState.projectiles.length-1];
        if (lastProj) {
            spawnFloatingText(lastProj.tx, lastProj.ty, "HIT!");
        } else {
            spawnFloatingText(canvas.width/2, canvas.height/2, "HIT!");
        }
        
        createParticles(true);
        
        if (gameState.vineProgress <= 0.0) {
            triggerVictory();
        } else {
            document.getElementById('float-mult').textContent = "x" + getCurrentMultiplier().toFixed(2);
        }
        
    } else {
        // BLOCK (Fail)
        createParticles(false);
    }
    updateUI();
}

function cashout() {
    if (!gameState.roundActive) return;
    
    const mult = getCurrentMultiplier();
    const winnings = gameState.betAmount * mult;
    gameState.balance += winnings;
    
    // Penalty push
    gameState.vineProgress += CONFIG.CashoutPenalty;
    
    if (gameState.vineProgress >= 1.0) {
        triggerDefeat();
    } else {
        alert(`Cashout! You won $${winnings.toFixed(2)}`);
        endRound();
    }
}

function triggerVictory() {
    const mult = getCurrentMultiplier();
    const winnings = gameState.betAmount * mult;
    gameState.balance += winnings;
    showOverlay('VICTORY', `You pushed it back! Won $${winnings.toFixed(2)}`, true);
    endRound();
}

function triggerDefeat() {
    showOverlay('DEFEAT', 'The vine reached the end!', false);
    endRound();
}

function showOverlay(title, text, isWin) {
    const el = document.getElementById('overlay');
    const tEl = document.getElementById('overlay-title');
    const pEl = document.getElementById('overlay-text');
    const b1 = document.getElementById('overlay-btn-1');
    const b2 = document.getElementById('overlay-btn-2');
    
    tEl.textContent = title;
    tEl.className = isWin ? 'status-title text-win' : 'status-title text-loss';
    pEl.textContent = text;
    el.style.display = 'flex';
    
    b1.textContent = isWin ? "Next Level" : "Retry";
    b1.onclick = () => {
        el.style.display = 'none';
        if (isWin) gameState.currentLevel++;
        gameState.vineProgress = CONFIG.StartProgress;
        updateUI();
    };
    
    b2.textContent = isWin ? "Stay" : "Quit";
    b2.onclick = () => {
        el.style.display = 'none';
        gameState.vineProgress = CONFIG.StartProgress;
        updateUI();
    };
}

function getCurrentMultiplier() {
    const diff = CONFIG.DIFFICULTIES[gameState.difficulty];
    // Based on consecutive hits
    if (gameState.consecutiveHits === 0) return 1.0;
    // Cap multiplier index
    const idx = Math.min(gameState.consecutiveHits - 1, diff.multipliers.length - 1);
    return diff.multipliers[idx];
}

/**
 * --- UI & INPUTS ---
 */
function updateUI() {
    document.getElementById('balance').textContent = `$${gameState.balance.toFixed(2)}`;
    document.getElementById('danger-level').textContent = Math.floor(gameState.vineProgress * 100) + "%";
    document.getElementById('level').textContent = gameState.currentLevel;
    document.getElementById('hits').textContent = gameState.consecutiveHits;
    updateMultiplierRow();
}

function generateMultipliers() {
    const container = document.getElementById('multiplier-row');
    container.innerHTML = '';
    const diff = CONFIG.DIFFICULTIES[gameState.difficulty];
    diff.multipliers.forEach((m, i) => {
        const div = document.createElement('div');
        div.className = 'mult-item';
        div.id = `mult-${i}`;
        div.textContent = `x${m.toFixed(1)}`;
        container.appendChild(div);
    });
}

function updateMultiplierRow() {
    const items = document.querySelectorAll('.mult-item');
    items.forEach((item, i) => {
        item.className = 'mult-item';
        if (i < gameState.consecutiveHits) item.classList.add('winning');
        if (i === gameState.consecutiveHits) item.classList.add('active');
    });
}

function lockUI(locked) {
    document.getElementById('bet-input').disabled = locked;
    document.querySelectorAll('.quick-btn').forEach(b => b.disabled = locked);
    document.querySelectorAll('.difficulty-btn').forEach(b => b.disabled = locked);
}

function setupInputs() {
    document.getElementById('bet-input').addEventListener('change', (e) => {
        let val = parseFloat(e.target.value);
        if (val < 0.01) val = 0.01;
        gameState.betAmount = val;
        saveState();
    });
    document.getElementById('btn-half').onclick = () => setBet(gameState.betAmount / 2);
    document.getElementById('btn-double').onclick = () => setBet(gameState.betAmount * 2);
    document.getElementById('btn-minus').onclick = () => adjustBetSequence(-1);
    document.getElementById('btn-plus').onclick = () => adjustBetSequence(1);

    document.querySelectorAll('.difficulty-btn').forEach(btn => {
        btn.onclick = () => {
            if (gameState.uiLocked) return;
            gameState.difficulty = btn.dataset.diff;
            document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            generateMultipliers();
            saveState();
        };
    });

    document.getElementById('play-btn').onclick = () => {
        if (gameState.roundActive) cashout();
        else startRound();
    };

    container.addEventListener('mousemove', (e) => {
        const rect = container.getBoundingClientRect();
        gameState.mouseX = e.clientX - rect.left;
        gameState.mouseY = e.clientY - rect.top;
        const ch = document.getElementById('crosshair');
        ch.style.left = gameState.mouseX + 'px';
        ch.style.top = gameState.mouseY + 'px';
    });

    container.addEventListener('mousedown', () => {
        if (gameState.roundActive && gameState.projectiles.length === 0) {
             onShoot();
        }
    });
}

function setBet(val) {
    if (gameState.uiLocked) return;
    if (val < 0.01) val = 0.01;
    if (val > 2000000) val = 2000000;
    gameState.betAmount = val;
    document.getElementById('bet-input').value = val.toFixed(2);
    saveState();
}

function adjustBetSequence(dir) {
    const seq = CONFIG.BET_SEQUENCE;
    let neu = gameState.betAmount;
    if (dir > 0) {
        for (let s of seq) if (s > gameState.betAmount + 0.001) { neu = s; break; }
    } else {
        for (let i = seq.length - 1; i >= 0; i--) if (seq[i] < gameState.betAmount - 0.001) { neu = seq[i]; break; }
    }
    setBet(neu);
}

/**
 * --- VISUALS ---
 */
function spawnProjectile(isSuccess) {
    // Target Front of Vine
    const pathLen = gameState.path.length;
    const progressIndex = Math.floor(gameState.vineProgress * pathLen);
    
    // Target slightly behind front (so it hits head not stem tip)
    const targetIndex = Math.max(0, progressIndex - 20); 
    
    let tx = canvas.width/2, ty = canvas.height/2;
    if (targetIndex < pathLen && targetIndex >= 0 && gameState.path[targetIndex]) {
        tx = gameState.path[targetIndex].x;
        ty = gameState.path[targetIndex].y;
    }

    const cx = canvas.width / 2;
    // Updated Cy position for offset ant
    const cy = (canvas.height / 2) + 50;

    // Angle for flash is based on MOUSE (visual)
    const mouseAngle = Math.atan2(gameState.mouseY - cy, gameState.mouseX - cx);
    const barrelLen = 40; 
    const muzzleX = cx + Math.cos(mouseAngle) * barrelLen;
    const muzzleY = cy + Math.sin(mouseAngle) * barrelLen;

    createMuzzleFlash(muzzleX, muzzleY, mouseAngle);

    gameState.projectiles.push({
        x: muzzleX, y: muzzleY,
        tx: tx, ty: ty,
        speed: 25,
        isSuccess: isSuccess,
        life: 100,
        trail: [] // Trail Array
    });
}

function spawnFloatingText(x, y, text) {
    gameState.floatingTexts.push({
        x: x, y: y,
        text: text,
        vy: -3,
        life: 1.0
    });
}

function createMuzzleFlash(x, y, angle) {
    // Acid Flash particles
    for(let i=0; i<12; i++) {
        const spread = (Math.random() - 0.5) * 1.0;
        const speed = 2 + Math.random() * 6;
        gameState.particles.push({
            x: x, y: y,
            vx: Math.cos(angle + spread) * speed,
            vy: Math.sin(angle + spread) * speed,
            // Acid colors: Lime, Yellow, Bright Green
            color: Math.random() > 0.5 ? '#ccff00' : '#adff2f',
            life: 0.4 + Math.random() * 0.3,
            size: 3 + Math.random() * 4,
            decay: 0.05
        });
    }
    // Big acid puff
    gameState.particles.push({
        x: x, y: y,
        vx: Math.cos(angle)*2, vy: Math.sin(angle)*2,
        color: 'rgba(200, 255, 0, 0.6)',
        life: 0.25,
        size: 20,
        decay: 0.08
    });
}

function createParticles(isWin) {
    const cx = gameState.projectiles[0]?.tx || canvas.width/2;
    const cy = gameState.projectiles[0]?.ty || canvas.height/2;
    
    // IMPACT SPLASH
    const count = isWin ? 40 : 20;
    
    for(let i=0; i<count; i++) {
        const speed = 3 + Math.random() * 12;
        const angle = Math.random() * Math.PI * 2;
        
        let color;
        if (isWin) {
            // Acid burning plant: Green slime + Smoke
            const r = Math.random();
            if (r > 0.6) color = '#ccff00'; // Neon Acid
            else if (r > 0.3) color = '#22c55e'; // Plant Green
            else color = '#ffffff'; // Foam
        } else {
            // Acid deflection: Bright sparks
            color = Math.random() > 0.5 ? '#adff2f' : '#ffffff';
        }

        gameState.particles.push({
            x: cx, y: cy,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            color: color,
            life: 0.6 + Math.random() * 0.6,
            size: 2 + Math.random() * 5,
            decay: 0.03
        });
    }
    
    // Acid Cloud
    gameState.particles.push({
        x: cx, y: cy,
        vx: 0, vy: 0,
        color: 'rgba(150, 255, 50, 0.4)',
        life: 0.6,
        size: 15,
        decay: 0.04,
        isShockwave: true,
        growth: 6
    });
}

function gameLoop() {
    updateGameLogic();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    drawTunnel();
    drawVine();
    drawProjectiles();
    drawParticles();
    drawFloatingTexts();
    drawCannon();
    
    requestAnimationFrame(gameLoop);
}

function drawTunnel() {
    if (gameState.path.length === 0) return;
    
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    // Shadow around tunnel
    ctx.lineWidth = 100;
    ctx.strokeStyle = '#0f0806'; // Very dark/black
    ctx.beginPath();
    ctx.moveTo(gameState.path[0].x, gameState.path[0].y);
    for(let p of gameState.path) ctx.lineTo(p.x, p.y);
    ctx.stroke();

    // Outer Edge of trench
    ctx.lineWidth = 80;
    ctx.strokeStyle = '#271c19'; // Match dark ground
    ctx.beginPath();
    ctx.moveTo(gameState.path[0].x, gameState.path[0].y);
    for(let p of gameState.path) ctx.lineTo(p.x, p.y);
    ctx.stroke();

    // Floor of trench
    ctx.lineWidth = 60;
    ctx.strokeStyle = '#3e2723'; // Base dirt
    ctx.beginPath();
    ctx.moveTo(gameState.path[0].x, gameState.path[0].y);
    for(let p of gameState.path) ctx.lineTo(p.x, p.y);
    ctx.stroke();
    
    // Center Glow / Shadow in Trench
    ctx.lineWidth = 40;
    ctx.strokeStyle = 'rgba(0,0,0,0.3)'; // Deep shadow
    ctx.stroke();

    // Goal (Skull)
    const end = gameState.path[gameState.path.length-1];
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(end.x, end.y, 40, 0, Math.PI*2);
    ctx.fill();
    ctx.font = '30px Arial';
    ctx.fillStyle = '#ef4444';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('☠️', end.x, end.y);
    
    // Start (Base)
    const start = gameState.path[0];
    ctx.fillStyle = '#15803d';
    ctx.beginPath();
    ctx.arc(start.x, start.y, 20, 0, Math.PI*2);
    ctx.fill();
}

function drawVine() {
    if (gameState.path.length === 0) return;
    
    const pathLen = gameState.path.length;
    // Current Front Index based on progress
    const frontIndex = Math.floor(gameState.vineProgress * pathLen);
    
    // 1. Draw Stem (Thick, Organic)
    if (frontIndex > 0) {
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        // Base Dark Green
        ctx.strokeStyle = '#064e3b'; 
        ctx.lineWidth = 14;
        ctx.beginPath();
        ctx.moveTo(gameState.path[0].x, gameState.path[0].y);
        for(let i=0; i<=frontIndex; i+=4) { const p = gameState.path[i]; ctx.lineTo(p.x, p.y); }
        const tip = gameState.path[frontIndex];
        if (tip) ctx.lineTo(tip.x, tip.y);
        ctx.stroke();

        // Inner Light Green (Tube effect)
        ctx.strokeStyle = '#15803d'; 
        ctx.lineWidth = 8;
        ctx.stroke();
        
        // Highlight
        ctx.strokeStyle = '#4ade80';
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.3;
        ctx.stroke();
        ctx.globalAlpha = 1.0;
    }
    
    // 2. Draw Heads
    for (const head of gameState.heads) {
        const headPathIdx = Math.floor(frontIndex - head.offset);
        
        if (headPathIdx < 0) continue;
        
        const p = gameState.path[headPathIdx];
        if (!p) continue;
        
        const pNext = gameState.path[Math.min(pathLen-1, headPathIdx + 5)];
        const pPrev = gameState.path[Math.max(0, headPathIdx - 5)];
        let angle = Math.atan2(pNext.y - pPrev.y, pNext.x - pPrev.x);
        
        // Front group is active
        const isActiveGroup = (head.groupIndex === 0);
        
        drawPiranhaHead(p.x, p.y, angle, head.side, head.color, isActiveGroup);
    }
}

function drawPiranhaHead(x, y, rotation, sideOffset, color, isActive) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(rotation);
    
    const offsetDist = CONFIG.ZigZagOffset * sideOffset;
    // Move to side
    ctx.translate(0, offsetDist);
    
    // STEM
    ctx.strokeStyle = '#1b5e20'; // Darker stem
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(0, -offsetDist); // Back to main vine
    ctx.lineTo(0, 0); // To head center
    ctx.stroke();
    
    const size = isActive ? 32 : 22;
    
    // LEAVES (Collar) - Draw BEHIND head
    ctx.fillStyle = '#4caf50';
    ctx.strokeStyle = '#1b5e20';
    ctx.lineWidth = 1;
    
    // Draw 3 distinct leaves at base
    for (let i = -1; i <= 1; i++) {
        ctx.beginPath();
        // Rotate leaf slightly
        const leafAngle = i * 0.5;
        // Shift rotation point to base
        ctx.rotate(leafAngle);
        
        // Draw leaf shape
        ctx.moveTo(-size*0.3, 0);
        ctx.quadraticCurveTo(-size*0.5, size*0.4, -size*0.8, 0);
        ctx.quadraticCurveTo(-size*0.5, -size*0.4, -size*0.3, 0);
        
        ctx.fill();
        ctx.stroke();
        
        // Reset rotation for next leaf
        ctx.rotate(-leafAngle);
    }

    // HEAD BULB (Pacman shape properly oriented)
    const headGrad = ctx.createRadialGradient(-size*0.2, -size*0.2, size*0.1, 0, 0, size);
    if (isActive) {
        headGrad.addColorStop(0, '#ef4444'); // Bright Red
        headGrad.addColorStop(1, '#991b1b'); // Deep Red
    } else {
        headGrad.addColorStop(0, color); 
        headGrad.addColorStop(1, '#1a1a1a'); 
    }
    ctx.fillStyle = headGrad;

    if (isActive) {
        // OPEN MOUTH
        ctx.beginPath();
        // Mouth angle logic: 0 is right (forward).
        ctx.arc(0, 0, size, 0.25 * Math.PI, 1.75 * Math.PI); 
        ctx.lineTo(-size*0.4, 0); // Deeper Throat
        ctx.closePath();
        ctx.fill();
        
        // LIPS (Thick)
        ctx.strokeStyle = '#f472b6'; // Hot Pink
        ctx.lineWidth = 6;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        // Upper Lip
        ctx.moveTo(-size*0.4, 0);
        ctx.lineTo(size * Math.cos(1.75*Math.PI), size * Math.sin(1.75*Math.PI));
        ctx.stroke();
        
        // Lower Lip
        ctx.beginPath();
        ctx.moveTo(-size*0.4, 0);
        ctx.lineTo(size * Math.cos(0.25*Math.PI), size * Math.sin(0.25*Math.PI));
        ctx.stroke();

        // TEETH (Sharp White Triangles)
        ctx.fillStyle = '#ffffff';
        // Top Teeth
        ctx.beginPath();
        ctx.moveTo(size*0.2, -size*0.2); ctx.lineTo(size*0.4, -size*0.6); ctx.lineTo(size*0.6, -size*0.2);
        ctx.fill();
        
        // Bottom Teeth
        ctx.beginPath();
        ctx.moveTo(size*0.2, size*0.2); ctx.lineTo(size*0.4, size*0.6); ctx.lineTo(size*0.6, size*0.2);
        ctx.fill();

    } else {
        // CLOSED BUD
        ctx.beginPath();
        ctx.arc(0, 0, size, 0, Math.PI*2);
        ctx.fill();
        
        // Big Pink Lips (Puckered)
        ctx.strokeStyle = '#f472b6';
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.moveTo(size*0.8, 0);
        ctx.lineTo(size*0.2, 0);
        ctx.stroke();
        
        // Vertical creases
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(size*0.8, -3); ctx.lineTo(size*0.8, 3); ctx.stroke();
    }
    
    // Spots
    if (color !== '#ef4444') { // Only on colored heads
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.beginPath();
        ctx.arc(-size*0.4, -size*0.35, size*0.25, 0, Math.PI*2);
        ctx.arc(0, -size*0.6, size*0.15, 0, Math.PI*2);
        ctx.arc(-size*0.2, size*0.5, size*0.18, 0, Math.PI*2);
        ctx.fill();
    }
    
    ctx.restore();
}

function drawCannon() {
    const cx = canvas.width / 2;
    // Updated Y position
    const cy = (canvas.height / 2) + 50; 
    const angle = Math.atan2(gameState.mouseY - cy, gameState.mouseX - cx);
    
    // Draw Base (Mound)
    ctx.save();
    ctx.translate(cx, cy);
    
    // Mound Shadow/Hole
    ctx.fillStyle = '#1a100c'; // Very Dark
    ctx.beginPath();
    ctx.arc(0, 0, 45, 0, Math.PI*2);
    ctx.fill();
    
    // Mound Rim Highlight
    ctx.strokeStyle = '#5d4037';
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.arc(0, 0, 45, 0, Math.PI*2);
    ctx.stroke();
    
    // Rotate for Ant Body
    ctx.rotate(angle);
    
    // Add Shadow to entire ant
    ctx.shadowColor = 'rgba(0,0,0,0.8)';
    ctx.shadowBlur = 20;
    ctx.shadowOffsetX = 8;
    ctx.shadowOffsetY = 8;

    // --- ANT DRAWING ---
    // Vibrant Orange/Amber Color Palette
    const antPrimary = '#fbbf24'; // Amber 400
    const antDark = '#b45309';    // Amber 700
    const antLight = '#fcd34d';   // Amber 300
    
    // Legs (6 legs)
    ctx.strokeStyle = '#78350f'; // Dark Brown legs
    ctx.lineWidth = 5;
    ctx.lineCap = 'round';
    
    // Middle legs
    ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(10, -35); ctx.lineTo(25, -45); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(10, 35); ctx.lineTo(25, 45); ctx.stroke();
    // Back legs
    ctx.beginPath(); ctx.moveTo(-10, 0); ctx.lineTo(-20, -35); ctx.lineTo(-35, -40); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(-10, 0); ctx.lineTo(-20, 35); ctx.lineTo(-35, 40); ctx.stroke();
    // Front legs
    ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(25, -25); ctx.lineTo(40, -30); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(25, 25); ctx.lineTo(40, 30); ctx.stroke();

    // Abdomen (Rear) - Big, dark, shiny
    const abdomenGrad = ctx.createRadialGradient(-35, 0, 5, -35, 0, 25);
    abdomenGrad.addColorStop(0, antLight); 
    abdomenGrad.addColorStop(0.4, antPrimary); 
    abdomenGrad.addColorStop(1, antDark); 
    
    ctx.fillStyle = abdomenGrad;
    ctx.strokeStyle = '#451a03'; // Deep outline
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.ellipse(-35, 0, 25, 18, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();
    
    // Stripes on abdomen
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath(); ctx.ellipse(-30, 0, 3, 10, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(-40, 0, 3, 12, 0, 0, Math.PI*2); ctx.fill();
    
    // Thorax (Middle)
    const thoraxGrad = ctx.createRadialGradient(0, 0, 2, 0, 0, 15);
    thoraxGrad.addColorStop(0, antPrimary);
    thoraxGrad.addColorStop(1, antDark);
    
    ctx.fillStyle = thoraxGrad;
    ctx.beginPath();
    ctx.ellipse(0, 0, 15, 12, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();
    
    // Head (Front)
    const headGrad = ctx.createRadialGradient(25, 0, 3, 25, 0, 18);
    headGrad.addColorStop(0, antLight);
    headGrad.addColorStop(1, antDark);
    
    ctx.fillStyle = headGrad;
    ctx.beginPath();
    ctx.ellipse(25, 0, 18, 15, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();
    
    // Eyes
    ctx.fillStyle = '#000'; // Black shiny eyes
    ctx.beginPath();
    ctx.ellipse(32, -8, 5, 4, 0, 0, Math.PI*2); // Right eye
    ctx.fill();
    // Eye shine
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(33, -9, 1.5, 0, Math.PI*2); ctx.fill();
    
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.ellipse(32, 8, 5, 4, 0, 0, Math.PI*2); // Left eye
    ctx.fill();
    // Eye shine
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(33, 7, 1.5, 0, Math.PI*2); ctx.fill();
    
    // Mandibles (Jaws)
    ctx.fillStyle = '#451a03';
    ctx.beginPath();
    // Left mandible
    ctx.moveTo(35, -5); ctx.lineTo(55, -12); ctx.lineTo(45, -2); ctx.fill();
    // Right mandible
    ctx.moveTo(35, 5); ctx.lineTo(55, 12); ctx.lineTo(45, 2); ctx.fill();
    
    // Antennae
    ctx.strokeStyle = '#78350f';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(35, -5); ctx.quadraticCurveTo(50, -25, 65, -15); ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(35, 5); ctx.quadraticCurveTo(50, 25, 65, 15); ctx.stroke();

    ctx.restore();
}

function drawProjectiles() {
    for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
        const p = gameState.projectiles[i];
        
        const dx = p.tx - p.x;
        const dy = p.ty - p.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        if (dist < p.speed) {
            resolveShot(p.isSuccess);
            gameState.projectiles.splice(i, 1);
            continue;
        }
        
        const vx = (dx/dist) * p.speed;
        const vy = (dy/dist) * p.speed;
        p.x += vx;
        p.y += vy;
        
        // --- ACID TRAIL ---
        p.trail.push({x: p.x, y: p.y});
        if (p.trail.length > 10) p.trail.shift();

        if (p.trail.length > 1) {
            ctx.beginPath();
            ctx.moveTo(p.trail[0].x, p.trail[0].y);
            for (let j = 1; j < p.trail.length; j++) {
                ctx.lineTo(p.trail[j].x, p.trail[j].y);
            }
            ctx.lineCap = 'round';
            ctx.lineWidth = 5;
            // Acid Fume Color
            ctx.strokeStyle = 'rgba(173, 255, 47, 0.4)'; 
            ctx.stroke();
            
            ctx.lineWidth = 2;
            ctx.strokeStyle = 'rgba(204, 255, 0, 0.8)';
            ctx.stroke();
        }

        // --- ACID CORE ---
        const grad = ctx.createRadialGradient(p.x, p.y, 2, p.x, p.y, 12);
        grad.addColorStop(0, '#ffffff');       // White Hot Center
        grad.addColorStop(0.3, '#ccff00');     // Neon Acid
        grad.addColorStop(1, 'rgba(100, 255, 0, 0)'); // Glow
        
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 12, 0, Math.PI*2);
        ctx.fill();
    }
}

function drawParticles() {
    for (let i = gameState.particles.length - 1; i >= 0; i--) {
        const p = gameState.particles[i];
        
        if (p.isShockwave) {
            p.size += p.growth;
            p.life -= p.decay;
            if (p.life <= 0) { gameState.particles.splice(i, 1); continue; }
            
            ctx.strokeStyle = p.color;
            ctx.lineWidth = 3 * p.life;
            ctx.globalAlpha = p.life;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
            ctx.stroke();
            ctx.globalAlpha = 1.0;
            continue;
        }

        p.x += p.vx;
        p.y += p.vy;
        p.life -= p.decay;
        
        if (p.life <= 0) {
            gameState.particles.splice(i, 1);
            continue;
        }
        
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

function drawFloatingTexts() {
    for (let i = gameState.floatingTexts.length - 1; i >= 0; i--) {
        const ft = gameState.floatingTexts[i];
        
        ft.y += ft.vy;
        ft.life -= 0.02;
        
        if (ft.life <= 0) {
            gameState.floatingTexts.splice(i, 1);
            continue;
        }
        
        ctx.save();
        ctx.globalAlpha = ft.life;
        ctx.translate(ft.x, ft.y);
        
        // Scale effect (pop up)
        const scale = 1 + Math.sin(ft.life * Math.PI) * 0.5;
        ctx.scale(scale, scale);
        
        ctx.font = "900 36px 'Arial Black', sans-serif";
        ctx.textAlign = "center";
        
        // Comic Style Text
        ctx.lineWidth = 6;
        ctx.strokeStyle = "black";
        ctx.strokeText(ft.text, 0, 0);
        
        ctx.fillStyle = "#fbbf24"; // Amber/Yellow fill
        ctx.fillText(ft.text, 0, 0);
        
        // White highlight inside
        ctx.lineWidth = 1;
        ctx.strokeStyle = "white";
        ctx.strokeText(ft.text, 0, 0);
        
        ctx.restore();
    }
}

initGame();
</script>
</body>
</html>