<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ants vs Plants - Towers Mode</title>
    <style>
        :root {
            --primary: #fbbf24; /* Brighter Amber */
            --primary-dark: #b45309;
            --bg-dark: #1c1917;
            --panel-bg: #292524;
            --text-light: #e7e5e4;
            --accent-green: #4ade80; /* Neon Green */
            --accent-red: #f87171;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: #2b1d16; /* Darker brown background for the page */
            background: linear-gradient(180deg, #2b1d16 0%, #1a0f0a 100%);
            color: var(--text-light);
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .game-wrapper {
            position: relative;
            width: 100%;
            max-width: 1200px;
            height: 100vh;
            max-height: 900px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 50px rgba(0,0,0,0.9);
            border-radius: 12px;
            overflow: hidden;
            background: #2a2018;
            border: 4px solid #5d4037; /* Brown border */
        }

        /* --- INFO BAR --- */
        .info-bar {
            display: flex;
            justify-content: center; /* Centered Balance */
            padding: 10px 20px;
            background: rgba(43, 29, 22, 0.95);
            border-bottom: 3px solid #5d4037;
            z-index: 10;
        }

        .info-item {
            text-align: center;
            min-width: 150px;
        }

        .info-label {
            color: #d7ccc8;
            font-size: 0.75rem;
            text-transform: uppercase;
            margin-bottom: 2px;
            font-weight: 700;
            letter-spacing: 1px;
        }

        .info-value {
            color: var(--primary);
            font-size: 1.2rem;
            font-weight: 900;
            text-shadow: 0 0 10px rgba(251, 191, 36, 0.4);
        }

        /* --- MULTIPLIER ROW --- */
        .multiplier-row {
            display: flex;
            gap: 6px;
            justify-content: center;
            padding: 12px;
            background: #3e2723;
            border-bottom: 3px solid #5d4037;
            z-index: 9;
            overflow-x: auto;
        }

        .mult-item {
            padding: 6px 12px;
            background: #5d4037;
            border: 2px solid #795548;
            border-radius: 6px;
            color: #d7ccc8;
            font-weight: 800;
            font-size: 0.95rem;
            min-width: 55px;
            text-align: center;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .mult-item.active {
            background: #0284c7;
            border-color: #38bdf8;
            color: #fff;
            transform: scale(1.15) translateY(-2px);
            box-shadow: 0 4px 15px rgba(14, 165, 233, 0.5);
            z-index: 2;
        }

        .mult-item.winning {
            background: #15803d;
            border-color: #4ade80;
            color: #fff;
        }

        /* --- CANVAS AREA --- */
        .canvas-container {
            flex: 1;
            position: relative;
            background-color: #f0c27b; /* Sandy Base */
            /* Complex gradient to simulate the sandy/organic texture from reference */
            background-image: 
                radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.1) 0%, transparent 40%),
                radial-gradient(circle at 80% 80%, rgba(139, 69, 19, 0.15) 0%, transparent 40%),
                linear-gradient(135deg, #f5dba8 0%, #e6a865 100%),
                url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.08'/%3E%3C/svg%3E");
            background-blend-mode: normal, normal, multiply, overlay;
            
            cursor: none;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            position: relative;
            z-index: 1;
        }

        .crosshair {
            position: absolute;
            width: 44px;
            height: 44px;
            pointer-events: none;
            z-index: 100;
            transform: translate(-50%, -50%);
            display: none;
            border: 3px solid rgba(173, 255, 47, 0.8); 
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(173, 255, 47, 0.6);
            transition: transform 0.05s;
        }

        .crosshair::before, .crosshair::after {
            content: '';
            position: absolute;
            background: #ccff00;
            box-shadow: 0 0 8px #ccff00;
        }
        .crosshair::before { top: 19px; left: 6px; width: 32px; height: 3px; }
        .crosshair::after { left: 19px; top: 6px; height: 32px; width: 3px; }
        
        /* Updated Crosshair Label to be large and premium */
        .crosshair-label {
            position: absolute;
            top: 55px; /* Moved down slightly */
            left: 50%;
            transform: translateX(-50%);
            color: var(--primary);
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid var(--primary);
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 1.4rem; /* Larger font */
            font-weight: 900;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.8);
            text-shadow: 0 0 10px rgba(251, 191, 36, 0.5);
            white-space: nowrap;
            z-index: 102;
            pointer-events: none;
        }

        /* Hidden current-mult-float as requested */
        .current-mult-float {
            display: none !important;
        }

        /* --- CONTROLS BAR --- */
        .controls {
            background: linear-gradient(135deg, #2b1d16 0%, #1a0f0a 100%);
            padding: 20px;
            border-top: 4px solid #5d4037;
            display: grid;
            grid-template-columns: 1fr 1.5fr 1fr;
            gap: 25px;
            align-items: center;
            position: relative;
            z-index: 20;
            box-shadow: 0 -10px 30px rgba(0,0,0,0.5);
        }

        @media (max-width: 768px) {
            .controls { grid-template-columns: 1fr; padding: 15px; }
        }

        .control-col { display: flex; flex-direction: column; gap: 10px; }
        .label { color: var(--primary); font-size: 0.85rem; font-weight: 800; text-transform: uppercase; letter-spacing: 1px; }

        .bet-input-group {
            display: flex;
            align-items: center;
            gap: 5px;
            background: #000;
            padding: 8px;
            border-radius: 8px;
            border: 2px solid #4b5563;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.5);
        }

        .bet-input-group input {
            background: transparent;
            border: none;
            color: #fff;
            font-size: 1.4rem;
            font-weight: 900;
            width: 100%;
            text-align: center;
            outline: none;
        }

        .quick-buttons { display: flex; gap: 6px; justify-content: center; }
        
        .quick-btn {
            padding: 8px 12px;
            background: linear-gradient(to bottom, #5d4037, #3e2723);
            border: 1px solid #2b1d16;
            border-radius: 6px;
            color: #e5e7eb;
            font-weight: 800;
            font-size: 0.75rem;
            cursor: pointer;
            flex: 1;
            box-shadow: 0 2px 0 #1c1917;
            transition: all 0.1s;
        }
        .quick-btn:hover:not(:disabled) { background: #795548; transform: translateY(-1px); }
        .quick-btn:active:not(:disabled) { transform: translateY(2px); box-shadow: none; }
        .quick-btn:disabled { opacity: 0.4; cursor: not-allowed; }

        .difficulty-buttons {
            display: flex;
            gap: 6px;
            background: #2b1d16;
            padding: 6px;
            border-radius: 10px;
            border: 1px solid #4e342e;
        }

        .difficulty-btn {
            flex: 1;
            padding: 12px 5px;
            background: transparent;
            border: 1px solid transparent;
            color: #a1887f;
            font-weight: 800;
            font-size: 0.8rem;
            cursor: pointer;
            border-radius: 6px;
            text-transform: uppercase;
            transition: 0.2s;
        }

        .difficulty-btn.active {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            border: 1px solid #34d399;
            box-shadow: 0 4px 10px rgba(16, 185, 129, 0.4);
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        .difficulty-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .play-button {
            width: 100%;
            height: 70px;
            background: linear-gradient(135deg, #0ea5e9, #0369a1);
            border: 2px solid #38bdf8;
            border-bottom-width: 6px;
            border-radius: 12px;
            color: white;
            font-size: 1.8rem;
            font-weight: 900;
            text-transform: uppercase;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(14, 165, 233, 0.4);
            transition: all 0.1s;
            text-shadow: 0 2px 0 rgba(0,0,0,0.3);
            letter-spacing: 1px;
        }
        
        .play-button:active:not(:disabled) {
            transform: translateY(4px);
            border-bottom-width: 2px;
            box-shadow: none;
        }
        
        .play-button.cashout {
            background: linear-gradient(135deg, #22c55e, #15803d);
            border-color: #86efac;
            box-shadow: 0 5px 15px rgba(34, 197, 94, 0.4);
        }

        .play-button:disabled {
            background: #4b5563;
            border-color: #6b7280;
            box-shadow: none;
            cursor: not-allowed;
            transform: none;
            border-bottom-width: 2px;
        }

        .status-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            display: none;
        }
        
        .status-content {
            background: #1c1917;
            border: 4px solid var(--primary);
            padding: 50px;
            border-radius: 20px;
            text-align: center;
            animation: zoomIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }

        @keyframes zoomIn { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        .status-title { font-size: 3rem; margin-bottom: 15px; text-transform: uppercase; font-weight: 900; letter-spacing: 2px; }
        .status-text { font-size: 1.4rem; color: #d1d5db; margin-bottom: 30px; }
        .status-btn {
            padding: 15px 40px;
            background: var(--primary);
            color: #000;
            border: 2px solid #fcd34d;
            font-weight: 900;
            font-size: 1.1rem;
            border-radius: 8px;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 4px 0 #b45309;
            transition: all 0.1s;
        }
        .status-btn:active { transform: translateY(4px); box-shadow: none; }
        .status-btn:hover { background: #fbbf24; filter: brightness(1.1); }

        .text-win { color: #4ade80; text-shadow: 0 0 20px rgba(74, 222, 128, 0.6); }
        .text-loss { color: #f87171; text-shadow: 0 0 20px rgba(248, 113, 113, 0.6); }

    </style>
</head>
<body>

<div class="game-wrapper">
    <!-- Info Bar -->
    <div class="info-bar">
        <div class="info-item">
            <div class="info-label">BALANCE</div>
            <div class="info-value" id="balance">$1000.00</div>
        </div>
    </div>

    <!-- Multiplier Row -->
    <div class="multiplier-row" id="multiplier-row">
        <!-- JS Generated -->
    </div>

    <!-- Canvas -->
    <div class="canvas-container" id="canvas-container">
        <canvas id="gameCanvas"></canvas>
        <div class="crosshair" id="crosshair">
            <div class="crosshair-label" id="crosshair-mult">x1.0</div>
        </div>
        <div class="current-mult-float" id="float-mult">x1.00</div>
    </div>

    <!-- Controls -->
    <div class="controls">
        <!-- Bet Amount -->
        <div class="control-col">
            <div class="label">BET AMOUNT</div>
            <div class="bet-input-group">
                <span style="color:var(--primary); font-weight:bold; margin-left:5px;">$</span>
                <input type="number" id="bet-input" value="10.00" step="0.01">
            </div>
            <div class="quick-buttons">
                <button class="quick-btn" id="btn-half">1/2</button>
                <button class="quick-btn" id="btn-double">2X</button>
                <button class="quick-btn" id="btn-minus">-</button>
                <button class="quick-btn" id="btn-plus">+</button>
            </div>
        </div>

        <!-- Difficulty -->
        <div class="control-col">
            <div class="label" style="text-align:center;">DIFFICULTY</div>
            <div class="difficulty-buttons" id="diff-container">
                <button class="difficulty-btn" data-diff="easy">Easy</button>
                <button class="difficulty-btn active" data-diff="medium">Medium</button>
                <button class="difficulty-btn" data-diff="hard">Hard</button>
                <button class="difficulty-btn" data-diff="expert">Expert</button>
                <button class="difficulty-btn" data-diff="crazy">Crazy</button>
            </div>
        </div>

        <!-- Play Button -->
        <div class="control-col">
            <button class="play-button" id="play-btn">PLAY</button>
        </div>
    </div>

    <!-- Overlay -->
    <div class="status-overlay" id="overlay">
        <div class="status-content">
            <h2 class="status-title" id="overlay-title">BIG WIN</h2>
            <p class="status-text" id="overlay-text">Plant Destroyed!</p>
            <div style="display:flex; gap:15px; justify-content:center;">
                <button class="status-btn" id="overlay-btn-1">Next Level</button>
                <button class="status-btn" id="overlay-btn-2" style="background:#4b5563; border-color:#6b7280; color:white;">Exit</button>
            </div>
        </div>
    </div>
</div>

<script>
/**
 * --- CONFIGURATION & CONSTANTS ---
 */
const CONFIG = {
    SegmentsCount: 8, 
    StartProgress: 0.5, 
    SegmentProgressStep: 0.08, 
    
    AdvanceStep: 1, 
    AdvanceOnCashout: 0.25, 
    LosePoint: 0.95, 

    Visuals: {
        HeadSpacing: 40, 
        GroupGap: 100, 
        CompressedSpacing: 8, 
        CompressedGroupGap: 15, 
        ZigZagOffset: 25, 
        LerpSpeed: 0.05 // Reduced for smoother animations
    },
    
    SnapDistance: 60, 
    
    BET_SEQUENCE: [
        0.01, 0.02, 0.05, 0.10, 0.20, 0.50,
        1.00, 2.00, 5.00, 10.00, 20.00, 50.00,
        100.00, 200.00, 500.00, 1000.00, 2000.00, 5000.00
    ],

    DIFFICULTIES: {
        easy: { label: 'Easy', probability: 0.75, multipliers: [1.1, 1.25, 1.5, 1.8, 2.2, 2.8, 3.6, 5.0] },
        medium: { label: 'Medium', probability: 0.667, multipliers: [1.2, 1.45, 1.85, 2.5, 3.5, 5.0, 7.5, 12.0] },
        hard: { label: 'Hard', probability: 0.50, multipliers: [1.4, 1.9, 2.8, 4.2, 6.5, 10.0, 16.0, 28.0] },
        expert: { label: 'Expert', probability: 0.333, multipliers: [1.7, 2.8, 5.0, 9.0, 16.0, 30.0, 60.0, 120.0] },
        crazy: { label: 'Crazy', probability: 0.25, multipliers: [2.2, 5.0, 12.0, 30.0, 75.0, 200.0, 500.0, 1250.0] }
    }
};

/**
 * --- GAME STATE ---
 */
const gameState = {
    balance: 1000.00,
    vineProgress: 0.5, 
    displayedVineProgress: 0.5, // For smooth animations
    plantPosition: 0, 
    currentLevel: 1,
    betAmount: 10.00,
    difficulty: 'medium',
    roundActive: false,
    consecutiveHits: 0,
    uiLocked: false,
    mouseX: 0,
    mouseY: 0,
    aimX: 0, 
    aimY: 0,
    snappedTarget: null, 
    path: [],
    projectiles: [],
    particles: [],
    floatingTexts: [],
    heads: [], 
    segments: [], 
    activeSegmentIndex: 0,
    totalVineLength: 0,
    visualVineLength: 0 
};

/**
 * --- CANVAS SETUP ---
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const container = document.getElementById('canvas-container');

function resize() {
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
    generatePath();
}
window.addEventListener('resize', resize);

/**
 * --- PATH & VINE GENERATION ---
 */
function generatePath() {
    const w = canvas.width;
    const h = canvas.height;
    gameState.path = [];

    const points = [
        {x: 0, y: 50},
        {x: w * 0.9, y: 50},
        {x: w * 0.9, y: h * 0.4},
        {x: w * 0.1, y: h * 0.45},
        {x: w * 0.1, y: h * 0.85},
        {x: w * 0.8, y: h * 0.85},
        {x: w - 50, y: h - 50}
    ];
    
    for (let i = 0; i < points.length - 1; i++) {
        const p0 = points[i];
        const p1 = points[i+1];
        const dist = Math.hypot(p1.x - p0.x, p1.y - p0.y);
        const steps = Math.floor(dist); 
        
        for (let j = 0; j < steps; j++) {
            const t = j / steps;
            gameState.path.push({
                x: p0.x + (p1.x - p0.x) * t,
                y: p0.y + (p1.y - p0.y) * t
            });
        }
    }
}

function generateVineHeads() {
    gameState.heads = [];
    gameState.segments = [];
    const colors = ['#ef4444', '#3b82f6', '#eab308', '#a855f7'];
    for (let g = 0; g < CONFIG.SegmentsCount; g++) {
        const color = colors[g % colors.length];
        const segmentHeads = [];
        for (let h = 0; h < 4; h++) {
            const headObj = {
                offset: 0, visualOffset: 0, side: (h % 2 === 0) ? -1 : 1, groupIndex: g, id: g * 4 + h
            };
            gameState.heads.push(headObj);
            segmentHeads.push(headObj);
        }
        gameState.segments.push({ index: g, color: color, heads: segmentHeads, compressed: false });
    }
    updateVineLayout(true);
}

function updateVineLayout(instant = false) {
    let currentDist = 0;
    for (let g = 0; g < gameState.segments.length; g++) {
        const seg = gameState.segments[g];
        const spacing = seg.compressed ? CONFIG.Visuals.CompressedSpacing : CONFIG.Visuals.HeadSpacing;
        const gap = seg.compressed ? CONFIG.Visuals.CompressedGroupGap : CONFIG.Visuals.GroupGap;
        for (let h = 0; h < seg.heads.length; h++) {
            currentDist += spacing;
            seg.heads[h].offset = currentDist;
            if (instant) seg.heads[h].visualOffset = currentDist;
        }
        currentDist += gap;
    }
    gameState.totalVineLength = currentDist;
    if (instant) gameState.visualVineLength = currentDist;
    updateVisualProgress();
}

function updateVisualProgress() {
    let targetP = CONFIG.StartProgress + (gameState.plantPosition * CONFIG.SegmentProgressStep);
    if (gameState.path.length > 0) {
        const activeSeg = gameState.segments[gameState.activeSegmentIndex];
        if (activeSeg) {
             let maxOffset = 0;
             activeSeg.heads.forEach(h => maxOffset = Math.max(maxOffset, h.offset));
             const minProgress = (maxOffset + 150) / gameState.path.length; 
             if (targetP < minProgress) targetP = minProgress;
        }
    }
    gameState.vineProgress = targetP;
}

/**
 * --- GAME LOGIC ---
 */

function initGame() {
    loadState();
    resize();
    generateVineHeads();
    gameState.displayedVineProgress = gameState.vineProgress;
    updateUI();
    generateMultipliers();
    setupInputs();
    requestAnimationFrame(gameLoop);
}

function loadState() {
    const saved = localStorage.getItem('antsVsPlants_state');
    if (saved) {
        const data = JSON.parse(saved);
        gameState.balance = data.balance ?? 1000;
        gameState.currentLevel = data.currentLevel ?? 1;
        gameState.betAmount = data.betAmount ?? 10;
        gameState.difficulty = data.difficulty ?? 'medium';
    }
    document.getElementById('bet-input').value = gameState.betAmount.toFixed(2);
    document.querySelectorAll('.difficulty-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.diff === gameState.difficulty);
    });
}

function saveState() {
    localStorage.setItem('antsVsPlants_state', JSON.stringify({
        balance: gameState.balance, currentLevel: gameState.currentLevel, betAmount: gameState.betAmount, difficulty: gameState.difficulty
    }));
}

function startRound() {
    if (gameState.betAmount > gameState.balance) {
        alert("Insufficient funds!");
        return;
    }
    gameState.balance -= gameState.betAmount;
    gameState.roundActive = true;
    gameState.consecutiveHits = 0;
    gameState.uiLocked = true;
    gameState.activeSegmentIndex = 0;
    gameState.segments.forEach(s => s.compressed = false);
    if (gameState.plantPosition < 0) gameState.plantPosition = 0;
    updateVineLayout();
    updateUI();
    lockUI(true);
    const btn = document.getElementById('play-btn');
    btn.textContent = "CASHOUT";
    btn.classList.add('cashout');
    document.getElementById('crosshair').style.display = 'block';
    document.getElementById('crosshair-mult').textContent = "x" + getTargetMultiplier().toFixed(1);
    saveState();
}

function endRound() {
    gameState.roundActive = false;
    gameState.uiLocked = false;
    updateUI();
    lockUI(false);
    const btn = document.getElementById('play-btn');
    btn.textContent = "PLAY";
    btn.classList.remove('cashout');
    document.getElementById('crosshair').style.display = 'none';
    saveState();
}

function updateGameLogic() {
    if (gameState.roundActive) {
        document.getElementById('crosshair-mult').textContent = "x" + getTargetMultiplier().toFixed(1);
    }
    
    // Lerp individual heads
    for (const head of gameState.heads) {
        head.visualOffset += (head.offset - head.visualOffset) * CONFIG.Visuals.LerpSpeed;
    }
    
    // Lerp total length
    gameState.visualVineLength += (gameState.totalVineLength - gameState.visualVineLength) * CONFIG.Visuals.LerpSpeed;
    
    // Lerp displayed progress
    gameState.displayedVineProgress += (gameState.vineProgress - gameState.displayedVineProgress) * CONFIG.Visuals.LerpSpeed;
    
    updateAim();
}

function updateAim() {
    gameState.aimX = gameState.mouseX;
    gameState.aimY = gameState.mouseY;
    gameState.snappedTarget = null;
    if (!gameState.roundActive) return;
    const activeSegment = gameState.segments[gameState.activeSegmentIndex];
    if (!activeSegment) return;
    const pathLen = gameState.path.length;
    
    // Use displayedVineProgress for smooth aim
    const frontIndex = Math.floor(gameState.displayedVineProgress * pathLen);
    
    let closestDist = CONFIG.SnapDistance;
    let bestHead = null;
    for (const head of activeSegment.heads) {
        // Use visualOffset
        const headPathIdx = Math.floor(frontIndex - head.visualOffset);
        if (headPathIdx < 0 || headPathIdx >= pathLen) continue; // Boundary check
        const p = gameState.path[headPathIdx];
        if (!p) continue; 

        const pNext = gameState.path[Math.min(pathLen-1, headPathIdx + 5)] || p;
        const pPrev = gameState.path[Math.max(0, headPathIdx - 5)] || p;
        
        let angle = Math.atan2(pNext.y - pPrev.y, pNext.x - pPrev.x);
        const zigZag = CONFIG.Visuals.ZigZagOffset * head.side;
        const headWorldX = p.x - Math.sin(angle) * zigZag;
        const headWorldY = p.y + Math.cos(angle) * zigZag;
        const dist = Math.hypot(gameState.mouseX - headWorldX, gameState.mouseY - headWorldY);
        if (dist < closestDist) {
            closestDist = dist;
            bestHead = { x: headWorldX, y: headWorldY, angle: angle, side: head.side, baseX: p.x, baseY: p.y, headRef: head };
        }
    }
    if (bestHead) { gameState.aimX = bestHead.x; gameState.aimY = bestHead.y; gameState.snappedTarget = bestHead; }
    const ch = document.getElementById('crosshair');
    ch.style.left = gameState.aimX + 'px';
    ch.style.top = gameState.aimY + 'px';
    if (gameState.snappedTarget) {
        ch.style.borderColor = '#ff0000'; ch.style.boxShadow = '0 0 15px rgba(255, 0, 0, 0.8)';
    } else {
        ch.style.borderColor = 'rgba(173, 255, 47, 0.8)'; ch.style.boxShadow = '0 0 15px rgba(173, 255, 47, 0.6)';
    }
}

function onShoot() {
    if (!gameState.roundActive) return;
    const diff = CONFIG.DIFFICULTIES[gameState.difficulty];
    const isSuccess = Math.random() < diff.probability;
    spawnProjectile(isSuccess);
}

function resolveShot(isSuccess) {
    if (isSuccess) {
        const currentSegment = gameState.segments[gameState.activeSegmentIndex];
        if (currentSegment) currentSegment.compressed = true; 
        gameState.activeSegmentIndex++;
        gameState.plantPosition -= CONFIG.AdvanceStep;
        gameState.consecutiveHits++;
        const lastProj = gameState.projectiles[gameState.projectiles.length-1];
        if (lastProj) spawnFloatingText(lastProj.tx, lastProj.ty, "HIT!", "#4ade80");
        createParticles(true);
        if (gameState.activeSegmentIndex >= CONFIG.SegmentsCount) triggerVictory();
    } else {
        gameState.segments.forEach(seg => seg.compressed = false);
        gameState.activeSegmentIndex = 0;
        gameState.consecutiveHits = 0;
        if (gameState.plantPosition < 0) gameState.plantPosition = 0;
        else gameState.plantPosition += CONFIG.AdvanceStep;
        const lastProj = gameState.projectiles[gameState.projectiles.length-1];
        if (lastProj) spawnFloatingText(lastProj.tx, lastProj.ty, "BLOCKED", "#f87171"); 
        createParticles(false);
        endRound();
        if (gameState.vineProgress >= CONFIG.LosePoint) triggerDefeat();
    }
    updateVineLayout();
    updateUI();
}

function cashout() {
    if (!gameState.roundActive) return;
    const mult = getCurrentMultiplier();
    const winnings = gameState.betAmount * mult;
    gameState.balance += winnings;
    gameState.plantPosition += CONFIG.AdvanceOnCashout;
    gameState.segments.forEach(s => s.compressed = false);
    gameState.activeSegmentIndex = 0;
    updateVineLayout();
    if (gameState.vineProgress >= CONFIG.LosePoint) triggerDefeat();
    else { alert(`Cashout! You won $${winnings.toFixed(2)}`); endRound(); }
}

function triggerVictory() {
    const mult = getCurrentMultiplier();
    const winnings = gameState.betAmount * mult;
    gameState.balance += winnings;
    showOverlay('BIG WIN', `Plant Destroyed! Win $${winnings.toFixed(2)}`, true);
    endRound();
    gameState.plantPosition = 0; 
    updateVineLayout();
}

function triggerDefeat() {
    showOverlay('DEFEAT', 'The plant took over the tunnel!', false);
    endRound();
    gameState.plantPosition = 0;
    updateVineLayout();
}

function showOverlay(title, text, isWin) {
    const el = document.getElementById('overlay');
    const tEl = document.getElementById('overlay-title');
    const pEl = document.getElementById('overlay-text');
    const b1 = document.getElementById('overlay-btn-1');
    const b2 = document.getElementById('overlay-btn-2');
    tEl.textContent = title;
    tEl.className = isWin ? 'status-title text-win' : 'status-title text-loss';
    pEl.textContent = text;
    el.style.display = 'flex';
    b1.textContent = isWin ? "Next Level" : "Try Again";
    b1.onclick = () => { el.style.display = 'none'; if (isWin) gameState.currentLevel++; updateUI(); };
    b2.textContent = isWin ? "Stay" : "Exit";
    b2.onclick = () => { el.style.display = 'none'; updateUI(); };
}

function getCurrentMultiplier() {
    const diff = CONFIG.DIFFICULTIES[gameState.difficulty];
    if (gameState.consecutiveHits === 0) return 1.0;
    const idx = Math.min(gameState.consecutiveHits - 1, diff.multipliers.length - 1);
    return diff.multipliers[idx];
}

function getTargetMultiplier() {
    const diff = CONFIG.DIFFICULTIES[gameState.difficulty];
    const idx = Math.min(gameState.consecutiveHits, diff.multipliers.length - 1);
    return diff.multipliers[idx];
}

/**
 * --- UI & INPUTS ---
 */
function updateUI() {
    document.getElementById('balance').textContent = `$${gameState.balance.toFixed(2)}`;
    updateMultiplierRow();
}

function generateMultipliers() {
    const container = document.getElementById('multiplier-row');
    container.innerHTML = '';
    const diff = CONFIG.DIFFICULTIES[gameState.difficulty];
    diff.multipliers.forEach((m, i) => {
        const div = document.createElement('div');
        div.className = 'mult-item';
        div.id = `mult-${i}`;
        div.textContent = `x${m.toFixed(1)}`;
        container.appendChild(div);
    });
}

function updateMultiplierRow() {
    const items = document.querySelectorAll('.mult-item');
    items.forEach((item, i) => {
        item.className = 'mult-item';
        if (i < gameState.consecutiveHits) item.classList.add('winning');
        if (i === gameState.consecutiveHits) item.classList.add('active');
    });
}

function lockUI(locked) {
    document.getElementById('bet-input').disabled = locked;
    document.querySelectorAll('.quick-btn').forEach(b => b.disabled = locked);
    document.querySelectorAll('.difficulty-btn').forEach(b => b.disabled = locked);
}

function setupInputs() {
    document.getElementById('bet-input').addEventListener('change', (e) => {
        let val = parseFloat(e.target.value);
        if (val < 0.01) val = 0.01;
        gameState.betAmount = val;
        saveState();
    });
    document.getElementById('btn-half').onclick = () => setBet(gameState.betAmount / 2);
    document.getElementById('btn-double').onclick = () => setBet(gameState.betAmount * 2);
    document.getElementById('btn-minus').onclick = () => adjustBetSequence(-1);
    document.getElementById('btn-plus').onclick = () => adjustBetSequence(1);

    document.querySelectorAll('.difficulty-btn').forEach(btn => {
        btn.onclick = () => {
            if (gameState.uiLocked) return;
            gameState.difficulty = btn.dataset.diff;
            document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            generateMultipliers();
            saveState();
        };
    });

    document.getElementById('play-btn').onclick = () => {
        if (gameState.roundActive) cashout();
        else startRound();
    };

    container.addEventListener('mousemove', (e) => {
        const rect = container.getBoundingClientRect();
        gameState.mouseX = e.clientX - rect.left;
        gameState.mouseY = e.clientY - rect.top;
    });

    container.addEventListener('mousedown', (e) => {
        if (!gameState.roundActive || gameState.projectiles.length > 0) return; 
        const activeSegment = gameState.segments[gameState.activeSegmentIndex];
        if (!activeSegment) return;
        let clickedHead = false;
        if (gameState.snappedTarget) clickedHead = true;
        else {
             let minDist = 50; 
             // Use displayedVineProgress
             const frontIndex = Math.floor(gameState.displayedVineProgress * gameState.path.length);
             for (const head of activeSegment.heads) {
                const idx = Math.floor(frontIndex - head.visualOffset);
                if (idx < 0 || idx >= gameState.path.length) continue;
                const p = gameState.path[idx];
                if (Math.hypot(gameState.aimX - p.x, gameState.aimY - p.y) < minDist) clickedHead = true;
            }
        }
        if (clickedHead) onShoot();
    });
}

function setBet(val) {
    if (gameState.uiLocked) return;
    if (val < 0.01) val = 0.01;
    if (val > 2000000) val = 2000000;
    gameState.betAmount = val;
    document.getElementById('bet-input').value = val.toFixed(2);
    saveState();
}

function adjustBetSequence(dir) {
    const seq = CONFIG.BET_SEQUENCE;
    let neu = gameState.betAmount;
    if (dir > 0) { for (let s of seq) if (s > gameState.betAmount + 0.001) { neu = s; break; } }
    else { for (let i = seq.length - 1; i >= 0; i--) if (seq[i] < gameState.betAmount - 0.001) { neu = seq[i]; break; } }
    setBet(neu);
}

/**
 * --- VISUALS ---
 */
function spawnProjectile(isSuccess) {
    let tx = gameState.aimX, ty = gameState.aimY;
    const cx = canvas.width / 2, cy = (canvas.height / 2) + 50;
    const mouseAngle = Math.atan2(gameState.aimY - cy, gameState.aimX - cx);
    const barrelLen = 40;
    const muzzleX = cx + Math.cos(mouseAngle) * barrelLen;
    const muzzleY = cy + Math.sin(mouseAngle) * barrelLen;

    createMuzzleFlash(muzzleX, muzzleY, mouseAngle);

    gameState.projectiles.push({
        x: muzzleX, y: muzzleY,
        tx: tx, ty: ty,
        speed: 25,
        isSuccess: isSuccess,
        life: 100,
        trail: [] 
    });
}

function spawnFloatingText(x, y, text, color = "#fbbf24") {
    // Increased life for slower disappearance (was 1.0)
    gameState.floatingTexts.push({ x: x, y: y, text: text, color: color, vy: -3, life: 2.5 });
}

function createMuzzleFlash(x, y, angle) {
    for(let i=0; i<12; i++) {
        const spread = (Math.random() - 0.5) * 1.0;
        const speed = 2 + Math.random() * 6;
        gameState.particles.push({
            x: x, y: y,
            vx: Math.cos(angle + spread) * speed,
            vy: Math.sin(angle + spread) * speed,
            color: Math.random() > 0.5 ? '#ccff00' : '#adff2f',
            life: 0.4 + Math.random() * 0.3,
            size: 3 + Math.random() * 4,
            decay: 0.05
        });
    }
}

function createParticles(isWin) {
    const cx = gameState.projectiles[0]?.tx || canvas.width/2;
    const cy = gameState.projectiles[0]?.ty || canvas.height/2;
    const count = isWin ? 40 : 20;
    
    for(let i=0; i<count; i++) {
        const speed = 3 + Math.random() * 12;
        const angle = Math.random() * Math.PI * 2;
        let color = isWin ? (Math.random()>0.6?'#ccff00':(Math.random()>0.3?'#22c55e':'#ffffff')) : (Math.random()>0.5?'#adff2f':'#ffffff');

        gameState.particles.push({
            x: cx, y: cy,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            color: color,
            life: 0.6 + Math.random() * 0.6,
            size: 2 + Math.random() * 5,
            decay: 0.03
        });
    }

    gameState.particles.push({
        x: cx, y: cy, vx: 0, vy: 0,
        color: 'rgba(150, 255, 50, 0.4)',
        life: 0.6, size: 15, decay: 0.04,
        isShockwave: true, growth: 6
    });
}

function drawHoverHighlight() {
    if (!gameState.roundActive || !gameState.snappedTarget) return;
    const st = gameState.snappedTarget;
    ctx.save();
    ctx.translate(st.baseX, st.baseY); 
    ctx.rotate(st.angle); 
    const offsetDist = CONFIG.Visuals.ZigZagOffset * st.side;
    ctx.translate(0, offsetDist);
    
    const pulse = 1 + Math.sin(Date.now() * 0.015) * 0.1;
    const size = 32;
    
    ctx.shadowBlur = 25; 
    ctx.shadowColor = '#fbbf24'; 
    ctx.globalCompositeOperation = 'screen'; 
    ctx.lineWidth = 4;
    ctx.strokeStyle = `rgba(251, 191, 36, ${0.8 + pulse*0.2})`;
    
    ctx.beginPath();
    ctx.arc(0, 0, size * pulse, 0.25 * Math.PI, 1.75 * Math.PI); 
    ctx.lineTo(-size*0.4, 0);
    ctx.closePath();
    ctx.stroke();

    ctx.fillStyle = `rgba(251, 191, 36, 0.1)`;
    ctx.fill();
    ctx.restore();
}

function gameLoop() {
    updateGameLogic();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawTunnel(); drawVine(); drawProjectiles(); drawParticles(); drawFloatingTexts(); drawCannon(); drawHoverHighlight();
    requestAnimationFrame(gameLoop);
}

function drawTunnel() {
    if (gameState.path.length === 0) return;
    ctx.lineCap = 'round'; ctx.lineJoin = 'round';
    
    // Outer sandy border of the tunnel (Lighter)
    ctx.lineWidth = 60; // Was 120
    ctx.strokeStyle = '#C66B24'; 
    ctx.beginPath(); 
    ctx.moveTo(gameState.path[0].x, gameState.path[0].y); 
    for(let p of gameState.path) ctx.lineTo(p.x, p.y); 
    ctx.stroke();
    
    // Inner dark tunnel (Middle)
    ctx.lineWidth = 45; // Was 90
    ctx.strokeStyle = '#5B2B0E'; 
    ctx.stroke();
    
    // Inner shadow/depth (Darkest)
    ctx.lineWidth = 30; // Was 70
    ctx.strokeStyle = '#361A09'; 
    ctx.stroke();

    // Defeat Point (End)
    const end = gameState.path[gameState.path.length-1];
    
    // Dark circle background
    ctx.fillStyle = '#361A09'; // Match darkest tunnel color
    ctx.beginPath(); 
    ctx.arc(end.x, end.y, 35, 0, Math.PI*2); // Was 55, reduced to match thinner tunnel
    ctx.fill();
    
    // Skull Icon - scaled down
    ctx.font = '900 24px Arial'; // Was 40px
    ctx.fillStyle = '#d6b483'; // Bone color
    ctx.textAlign = 'center'; 
    ctx.textBaseline = 'middle';
    ctx.fillText('☠️', end.x, end.y); 
    
    // Start Point
    ctx.fillStyle = '#4ade80'; // Keep green for plant start
    ctx.beginPath(); ctx.arc(gameState.path[0].x, gameState.path[0].y, 15, 0, Math.PI*2); ctx.fill(); // Was 25
}

function drawVine() {
    const pathLen = gameState.path.length;
    const frontIndex = Math.floor(gameState.displayedVineProgress * pathLen); // Use displayedVineProgress
    
    if (frontIndex > 0) {
        ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        // Vine colors
        ctx.strokeStyle = '#064e3b'; ctx.lineWidth = 14; ctx.beginPath(); 
        ctx.moveTo(gameState.path[0].x, gameState.path[0].y);
        for(let i=0; i<=frontIndex; i+=4) { const p = gameState.path[Math.floor(i)]; if(p) ctx.lineTo(p.x, p.y); }
        ctx.stroke(); 
        
        ctx.strokeStyle = '#4caf50'; ctx.lineWidth = 8; ctx.stroke(); // Brighter Green
        ctx.strokeStyle = '#81c784'; ctx.lineWidth = 2; ctx.globalAlpha = 0.3; ctx.stroke(); ctx.globalAlpha = 1.0; // Highlights
    }
    
    for (let i = gameState.heads.length - 1; i >= 0; i--) {
        const head = gameState.heads[i], idx = Math.floor(frontIndex - head.visualOffset);
        if (idx < 0 || idx >= pathLen) continue; // Boundary check
        const p = gameState.path[idx];
        if (!p) continue; // Safety check

        // Use Math.min/max but also fallback to p if index invalid (edge case)
        const pNext = gameState.path[Math.min(pathLen-1, idx + 5)] || p;
        const pPrev = gameState.path[Math.max(0, idx - 5)] || p;
        
        let angle = Math.atan2(pNext.y - pPrev.y, pNext.x - pPrev.x);
        const segment = gameState.segments[head.groupIndex];
        
        if (segment.compressed) drawCompressedBud(p.x, p.y, angle, segment.color, head.side);
        else drawPiranhaHead(p.x, p.y, angle, head.side, segment.color, head.groupIndex === gameState.activeSegmentIndex);
    }
}

function drawCompressedBud(x, y, rotation, color, side) {
    ctx.save(); ctx.translate(x, y); ctx.rotate(rotation);
    const wiltOffset = side * 15; ctx.translate(0, wiltOffset); ctx.rotate(side * 0.5);
    const size = 8;
    
    // Star-like petals color of segment
    ctx.fillStyle = color;
    for (let i = 0; i < 8; i++) {
        ctx.save();
        ctx.rotate(i * Math.PI / 4);
        ctx.beginPath();
        ctx.ellipse(size * 1.2, 0, size * 0.8, size * 0.3, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    // Green bud
    ctx.fillStyle = '#4caf50'; ctx.beginPath(); ctx.arc(0, 0, size, 0, Math.PI*2); ctx.fill();
    ctx.restore();
}

function drawPiranhaHead(x, y, rotation, sideOffset, color, isActive) {
    ctx.save(); ctx.translate(x, y); ctx.rotate(rotation);
    const off = CONFIG.Visuals.ZigZagOffset * sideOffset;
    // Green stem
    ctx.strokeStyle = '#388e3c'; ctx.lineWidth = 6; ctx.beginPath(); ctx.moveTo(0, -off); ctx.lineTo(0, 0); ctx.stroke();
    ctx.translate(0, off);
    
    const size = isActive ? 32 : 22;

    // Petals BEHIND head
    ctx.save();
    // Shift back opposite to lips. Lips point right (0 rad), so shift left.
    ctx.translate(-size * 0.6, 0); 
    ctx.fillStyle = color;
    const petalCount = 8;
    for (let i = 0; i < petalCount; i++) {
        ctx.save();
        ctx.rotate(i * Math.PI * 2 / petalCount);
        ctx.beginPath();
        // Petals visible from behind head
        ctx.ellipse(0, 0, size * 0.8, size * 0.25, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
    ctx.restore();

    // Green head gradient
    const headGrad = ctx.createRadialGradient(-size*0.2, -size*0.2, size*0.1, 0, 0, size);
    headGrad.addColorStop(0, '#66bb6a'); // Light green
    headGrad.addColorStop(1, '#1b5e20'); // Dark green
    ctx.fillStyle = headGrad;

    // Animation for active heads
    let mouthGap = 0.25 * Math.PI; // Default open angle (45 degrees)
    let toothScale = 1.0;
    
    if (isActive) {
        // Animate mouth opening
        const t = Date.now() * 0.01;
        const anim = 0.5 + 0.5 * Math.sin(t); // 0 to 1
        // Map 0..1 to MinOpen..MaxOpen
        mouthGap = (0.05 + 0.2 * anim) * Math.PI;
        
        // Scale teeth so they don't poke out when mouth closes
        toothScale = 0.5 + 0.5 * anim; 
    }

    if (isActive) {
        // Open head shape with dynamic jaw
        const topLipAngle = mouthGap;
        const bottomLipAngle = 2 * Math.PI - mouthGap;
        
        ctx.beginPath(); 
        ctx.arc(0, 0, size, topLipAngle, bottomLipAngle); 
        ctx.lineTo(-size*0.4, 0); 
        ctx.closePath(); 
        ctx.fill();
        
        // Lips color of segment
        ctx.strokeStyle = color; ctx.lineWidth = 6; ctx.beginPath(); 
        // Bottom Lip
        ctx.moveTo(-size*0.4, 0); ctx.lineTo(size * Math.cos(bottomLipAngle), size * Math.sin(bottomLipAngle)); ctx.stroke();
        // Top Lip
        ctx.beginPath(); ctx.moveTo(-size*0.4, 0); ctx.lineTo(size * Math.cos(topLipAngle), size * Math.sin(topLipAngle)); ctx.stroke();
        
        // Teeth (scaled)
        ctx.fillStyle = '#ffffff'; 
        ctx.beginPath(); ctx.moveTo(size*0.2, -size*0.2 * toothScale); ctx.lineTo(size*0.4, -size*0.6 * toothScale); ctx.lineTo(size*0.6, -size*0.2 * toothScale); ctx.fill();
        ctx.beginPath(); ctx.moveTo(size*0.2, size*0.2 * toothScale); ctx.lineTo(size*0.4, size*0.6 * toothScale); ctx.lineTo(size*0.6, size*0.2 * toothScale); ctx.fill();
    } else {
        // Closed head
        ctx.beginPath(); ctx.arc(0, 0, size, 0, Math.PI*2); ctx.fill();
        // Lips color of segment
        ctx.strokeStyle = color; ctx.lineWidth = 5; ctx.beginPath(); ctx.moveTo(size*0.8, 0); ctx.lineTo(size*0.2, 0); ctx.stroke();
    }
    ctx.restore();
}

function drawCannon() {
    const cx = canvas.width / 2, cy = (canvas.height / 2) + 50;
    const angle = Math.atan2(gameState.aimY - cy, gameState.aimX - cx);
    
    ctx.save(); ctx.translate(cx, cy);
    ctx.fillStyle = '#1a100c'; ctx.beginPath(); ctx.arc(0, 0, 45, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = '#5d4037'; ctx.lineWidth = 6; ctx.stroke();
    
    ctx.rotate(angle);
    
    const antPrimary = '#fbbf24', antDark = '#b45309', legColor = '#78350f';
    ctx.strokeStyle = legColor; ctx.lineWidth = 4; ctx.lineCap = 'round';
    
    // Legs
    for(let i=-1; i<=1; i+=2) {
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-15, i*20); ctx.lineTo(-35, i*45); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(25, i*25); ctx.lineTo(45, i*35); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(20, 0); ctx.lineTo(35, i*20); ctx.lineTo(50, i*15); ctx.stroke();
    }
    
    // Abdomen
    const abGrad = ctx.createRadialGradient(-30, 0, 5, -30, 0, 25);
    abGrad.addColorStop(0, antPrimary); abGrad.addColorStop(1, antDark);
    ctx.fillStyle = abGrad; ctx.beginPath(); ctx.ellipse(-30, 0, 25, 18, 0, 0, Math.PI*2); ctx.fill();
    
    // Thorax
    ctx.fillStyle = antDark; ctx.beginPath(); ctx.ellipse(5, 0, 14, 10, 0, 0, Math.PI*2); ctx.fill();
    
    // Head
    ctx.beginPath(); ctx.moveTo(20, -10); ctx.quadraticCurveTo(45, -15, 45, 0); ctx.quadraticCurveTo(45, 15, 20, 10); ctx.fill();
    ctx.fillStyle = '#000'; ctx.beginPath(); ctx.ellipse(38, -8, 5, 3, Math.PI/4, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(38, 8, 5, 3, -Math.PI/4, 0, Math.PI*2); ctx.fill();
    
    ctx.restore();
}

function drawProjectiles() {
    for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
        const p = gameState.projectiles[i], dx = p.tx - p.x, dy = p.ty - p.y, dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < p.speed) { resolveShot(p.isSuccess); gameState.projectiles.splice(i, 1); continue; }
        
        p.x += (dx/dist)*p.speed; p.y += (dy/dist)*p.speed;
        p.trail.push({x: p.x, y: p.y}); if (p.trail.length > 10) p.trail.shift();

        if (p.trail.length > 1) {
            ctx.beginPath(); ctx.moveTo(p.trail[0].x, p.trail[0].y);
            for (let j = 1; j < p.trail.length; j++) ctx.lineTo(p.trail[j].x, p.trail[j].y);
            ctx.strokeStyle = 'rgba(173, 255, 47, 0.4)'; ctx.lineWidth = 5; ctx.stroke();
        }
        
        const grad = ctx.createRadialGradient(p.x, p.y, 2, p.x, p.y, 12);
        grad.addColorStop(0, '#ffffff'); grad.addColorStop(0.3, '#ccff00'); grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(p.x, p.y, 12, 0, Math.PI*2); ctx.fill();
    }
}

function drawParticles() {
    for (let i = gameState.particles.length - 1; i >= 0; i--) {
        const p = gameState.particles[i];
        if (p.isShockwave) {
            p.size += p.growth; p.life -= p.decay;
            if (p.life <= 0) { gameState.particles.splice(i, 1); continue; }
            ctx.strokeStyle = p.color; ctx.lineWidth = 3 * p.life; ctx.globalAlpha = p.life;
            ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.stroke();
        } else {
            p.x += p.vx; p.y += p.vy; p.life -= p.decay;
            if (p.life <= 0) { gameState.particles.splice(i, 1); continue; }
            ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
        }
        ctx.globalAlpha = 1.0;
    }
}

function drawFloatingTexts() {
    for (let i = gameState.floatingTexts.length - 1; i >= 0; i--) {
        const ft = gameState.floatingTexts[i]; ft.y += ft.vy; ft.life -= 0.015;
        if (ft.life <= 0) { gameState.floatingTexts.splice(i, 1); continue; }
        let alpha = ft.life > 1.0 ? 1.0 : ft.life;
        ctx.save(); ctx.globalAlpha = alpha; ctx.font = "900 36px Arial"; ctx.fillStyle = ft.color; ctx.textAlign = "center"; 
        ctx.lineWidth = 6; ctx.strokeStyle = "black"; ctx.strokeText(ft.text, ft.x, ft.y); ctx.fillText(ft.text, ft.x, ft.y); ctx.restore();
    }
}

initGame();
</script>
</body>
</html>